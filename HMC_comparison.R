# This script applies the coupled HMC from
# Heng & Jacob (2019, doi:10.1093/biomet/asy074) to the simulation with the
# mixture of Gaussians.

for (tmp in c("devtools", "doParallel", "doRNG", "matrixStats")) {
  
  if(!tmp %in% rownames(installed.packages())) {
    install.packages(tmp, dependencies = T)
  }
  
}

devtools::install_github("pierrejacob/debiasedhmc")
library(debiasedhmc)
library(doParallel)
library(doRNG)
registerDoParallel(cores = detectCores())


# We modify the function `debiasedhmc::unbiased_estimator` to provide us with
# the output that we are interested in.
coupled_MCMC <- function(
  logtarget,
  single_kernel,
  coupled_kernel,
  rinit,
  h = function(x) x,
  m = 1,
  max_iterations = Inf
){
  
  start_time <- proc.time()["elapsed"]
  
  # initialize
  chain_state1 <- rinit()
  current_pdf1 <- logtarget(chain_state1)
  
  # Different initalization that yields better coupling:
  chain_state2 <- chain_state1
  current_pdf2 <- current_pdf1
  
  h_both <- list()
  h_both[[2]] <- h(chain_state2)
  
  # move first chain
  iter <- 1
  res_single_kernel <- single_kernel(chain_state1, current_pdf1, iter)
  chain_state1 <- res_single_kernel$chain_state
  current_pdf1 <- res_single_kernel$current_pdf
  h_both[[1]] <- h(chain_state1)
  h_coupled <- list(h_both)
  
  # iterate
  meet <- FALSE
  finished <- FALSE
  meetingtime <- Inf
  # iter here is 1; at this point we have X_1,Y_0 and we are going to generate successively X_t,Y_{t-1} where iter = t
  while (!finished && iter < max_iterations) {
    
    # check if meeting happens
    if (!meet && all(chain_state1 == chain_state2)) {
      # recording meeting time tau
      meet <- TRUE
      meetingtime <- iter
      meet_time <- proc.time()["elapsed"]
    }
    
    iter <- iter + 1
    
    if (meet) {
      
      # only need to use single kernel after meeting
      res_single_kernel <- single_kernel(chain_state1, current_pdf1, iter)
      chain_state1 <- res_single_kernel$chain_state
      current_pdf1 <- res_single_kernel$current_pdf
      chain_state2 <- chain_state1
      current_pdf2 <- current_pdf1
      
      # Record h.
      h_coupled[[iter]] <- list(h(chain_state1), NULL)
      
    } else {
      
      # use coupled kernel
      res_coupled_kernel <- coupled_kernel(chain_state1, chain_state2, current_pdf1, current_pdf2, iter)
      chain_state1 <- res_coupled_kernel$chain_state1
      current_pdf1 <- res_coupled_kernel$current_pdf1
      chain_state2 <- res_coupled_kernel$chain_state2
      current_pdf2 <- res_coupled_kernel$current_pdf2
      
      # Record h
      h_coupled[[iter]] <- list(h(chain_state1), h(chain_state2))
      
    }
    
    # stop after max(m, tau) steps
    if (iter >= max(meetingtime, m)) finished <- TRUE
    
  }
  
  end_time <- proc.time()["elapsed"]
  if (!meet) meet_time <- end_time
  
  return(list(
    "meeting time" = meetingtime,
    "h coupled" = h_coupled,
    iteration = iter,
    finished = finished,
    "meet time" = meet_time - start_time,
    "additional time" = end_time - meet_time
  ))
}



x_star <- c(-3, 0)
D <- length(x_star)
# The data `y` are as generated by the Python code.
y <- as.numeric(readLines("y.txt"))


logtarget <- function(x) {
  
  res <- 0
  
  for (y_i in y) {
    res <- res + matrixStats::logSumExp(dnorm(x = y_i, mean = x, log = TRUE))
  }
  
  return(res)
  
}


gradlogtarget <- function(x) {
  
  res <- rep(0, length(x))
  
  for (y_i in y) {
    tmp <- dnorm(x = y_i, mean = x)
    res <- res + (y_i - x) * tmp / sum(tmp)
  }
  
  return(res)
  
}


rinit <- function(){
  return(rnorm(D))
}


hmc_stepsize <- 0.1
dimension <- D

# The following code is based on
# https://github.com/pierrejacob/debiasedhmc/blob/1a2eeeb041eea4e5c050e5188e7100f31e61e35b/inst/logistic/hmc.repeats.R
set.seed(1L) # initial seed

# no. of repetitions
nreps <- 1024L
min_iter <- 1e4L
max_iter <- min_iter

# stepsize and no. of steps with good contraction and small average compute time
stepsize <- hmc_stepsize
nsteps <- 1 + floor(1 / hmc_stepsize)

# define HMC kernel and coupled HMC kernel
hmc <- get_hmc_kernel(logtarget, gradlogtarget, stepsize, nsteps, dimension)

# define RWMH kernel and coupled RWMH kernel
omega <- 1 / 20 # probability of selecting coupled RWMH
Sigma_std <- 1e-3 # proposal standard deviation of RWMH
Sigma_proposal <- Sigma_std^2 * diag(1, dimension, dimension)
mh <- get_mh_kernel(logtarget, Sigma_proposal, dimension)

# define mixture kernel
mixture_kernel <- function(chain_state, current_pdf, iteration){
  if (runif(1) < omega){
    return(mh$kernel(chain_state, current_pdf, iteration))
  } else {
    return(hmc$kernel(chain_state, current_pdf, iteration))
  }
}

# define coupled mixture kernel
mixture_coupled_kernel <- function(chain_state1, chain_state2, current_pdf1, current_pdf2, iteration){
  if (runif(1) < omega){
    return(mh$coupled_kernel(chain_state1, chain_state2, current_pdf1, current_pdf2, iteration))
  } else {
    return(hmc$coupled_kernel(chain_state1, chain_state2, current_pdf1, current_pdf2, iteration))
  }
}

results <- foreach(irep = 1:nreps) %dorng% coupled_MCMC(
  logtarget = logtarget,
  single_kernel = mixture_kernel,
  coupled_kernel = mixture_coupled_kernel,
  rinit = rinit,
  h = function(x) sum(x[1:2] + x[1:2]^2),
  m = min_iter,
  max_iterations = max_iter
)

save(results, file = "HMC_comparison.RData")